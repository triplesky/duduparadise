
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç©¿è¶Šå¤ªç©º - å˜Ÿå˜Ÿä¹å›­</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; touch-action: none; }
        canvas { display: block; }
        
        /* UI è¦†ç›–å±‚ */
        .ui-layer { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; }
        
        .hud-text {
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        
        /* éœ“è™¹æŒ‰é’®é£æ ¼ */
        .neon-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            transition: all 0.2s;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
        .neon-btn:active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        /* èƒ½é‡æ¡åŠ¨ç”» */
        .energy-bar-container {
            background: rgba(0,0,0,0.5);
            border: 2px solid #444;
            transform: skewX(-20deg);
        }
        .energy-fill {
            background: linear-gradient(90deg, #ff0000, #ffaa00);
            box-shadow: 0 0 10px #ffaa00;
            transition: width 0.1s linear;
        }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        #game-over-modal {
            background: rgba(10, 20, 40, 0.95);
            border: 4px solid #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        
        /* Boss è­¦å‘Šæ¡ */
        #boss-warning {
            position: absolute;
            top: 30%;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 0, 0.6);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            text-align: center;
            padding: 20px 0;
            letter-spacing: 10px;
            text-shadow: 0 0 10px red;
            display: none;
            z-index: 40;
            animation: warningFlash 0.5s infinite alternate;
        }
        @keyframes warningFlash {
            from { opacity: 0.2; background: rgba(255, 0, 0, 0.1); }
            to { opacity: 1; background: rgba(255, 0, 0, 0.6); }
        }
    </style>
</head>
<body>

    <!-- æ¸¸æˆç”»å¸ƒ -->
    <canvas id="gameCanvas"></canvas>

    <!-- Boss è­¦å‘Š -->
    <div id="boss-warning">WARNING: BOSS DETECTED</div>

    <!-- UI å±‚ -->
    <div class="ui-layer flex flex-col justify-between p-4">
        
        <!-- é¡¶éƒ¨ HUD -->
        <div class="flex justify-between items-start">
            <!-- è¿”å›æŒ‰é’® -->
            <a href="game_nav.html" class="neon-btn rounded-full w-12 h-12 flex items-center justify-center text-xl no-underline z-50">
                ğŸ 
            </a>

            <!-- åˆ†æ•°ä¸èƒ½é‡ -->
            <div class="flex flex-col items-end gap-2">
                <div class="text-xl text-blue-300 font-bold tracking-widest" id="levelDisplay">STAGE 1</div>
                <div class="text-3xl font-black text-white hud-text tracking-wider" id="scoreDisplay">SCORE: 0</div>
                <div class="flex items-center gap-2">
                    <span class="text-xs text-yellow-400 font-bold">HP</span>
                    <div class="energy-bar-container w-32 h-4 rounded overflow-hidden">
                        <div id="hpBar" class="energy-fill h-full w-full"></div>
                    </div>
                </div>
                <!-- è¿›åº¦æç¤º -->
                <div class="text-xs text-gray-400 mt-1">
                    TARGET: <span id="killCount" class="text-white font-bold">0</span> / <span id="levelTarget" class="text-white">10</span>
                </div>
            </div>
        </div>

        <!-- åº•éƒ¨æ­¦å™¨çŠ¶æ€ (æ¨¡æ‹Ÿ) -->
        <div class="flex justify-between items-end pb-4">
            <div class="flex gap-4">
                <div id="weapon-icon" class="w-16 h-16 rounded-xl border-2 border-blue-500 bg-black/50 flex items-center justify-center relative overflow-hidden">
                    <div class="absolute inset-0 bg-blue-500/20"></div>
                    <span class="text-2xl">ğŸ”«</span>
                    <span class="absolute bottom-0 right-1 text-xs text-blue-300">AUTO</span>
                </div>
                <div id="shield-icon" class="w-16 h-16 rounded-xl border-2 border-yellow-500 bg-black/50 flex items-center justify-center relative opacity-30 grayscale transition-all duration-300">
                    <div class="absolute inset-0 bg-yellow-500/20"></div>
                    <span class="text-2xl">ğŸ›¡ï¸</span>
                    <div id="shield-cd" class="absolute inset-0 bg-black/80 flex items-center justify-center text-white text-xs hidden">CD</div>
                </div>
            </div>
            
            <!-- å¼•å¯¼æ–‡å­— -->
            <div id="start-hint" class="text-white/50 text-sm animate-pulse text-center w-full absolute bottom-10 left-0 pointer-events-none">
                æ»‘åŠ¨å±å¹•æ§åˆ¶æˆ˜æœº / è‡ªåŠ¨å°„å‡»
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸ/å¼€å§‹ é®ç½© -->
    <div id="game-overlay" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div id="game-over-modal" class="w-11/12 max-w-md p-8 rounded-3xl text-center transform transition-all scale-100">
            <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-blue-400 mb-2" style="font-family: 'ZCOOL KuaiLe'">é›·éœ†æˆ˜æœº</h1>
            <p class="text-blue-300 mb-8 tracking-widest text-sm">GALAXY DEFENDER</p>
            
            <div id="result-area" class="hidden mb-6">
                <p class="text-gray-400 text-sm">æœ¬æ¬¡å¾—åˆ†</p>
                <p id="final-score" class="text-4xl text-yellow-400 font-bold hud-text">0</p>
                <p id="final-level" class="text-lg text-blue-300 mt-2">æ­¢æ­¥äº STAGE 1</p>
            </div>

            <button id="start-btn" class="w-full py-4 rounded-xl bg-gradient-to-r from-blue-600 to-purple-600 text-white font-bold text-xl shadow-[0_0_20px_rgba(59,130,246,0.6)] hover:scale-105 active:scale-95 transition-transform">
                å¯åŠ¨å¼•æ“ START
            </button>
            <p class="text-xs text-gray-500 mt-4">æ¨èä½©æˆ´è€³æœºä½“éªŒéœ‡æ’¼éŸ³æ•ˆ ğŸ§</p>
        </div>
    </div>

    <script>
        /**
         * æ¸¸æˆå¼•æ“æ ¸å¿ƒé€»è¾‘
         */
        
        // --- éŸ³é¢‘ç®¡ç†å™¨ (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; 
                this.masterGain.connect(this.ctx.destination);
            }

            playShoot() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth'; 
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }
            
            playLaserShoot() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playExplosion() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const bufferSize = this.ctx.sampleRate * 0.5; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.4);
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(1.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playPowerUp() {
                 if (this.ctx.state === 'suspended') this.ctx.resume();
                 const osc = this.ctx.createOscillator();
                 const gain = this.ctx.createGain();
                 osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                 osc.frequency.linearRampToValueAtTime(1200, this.ctx.currentTime + 0.3);
                 osc.type = 'sine';
                 gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                 gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                 osc.connect(gain);
                 gain.connect(this.masterGain);
                 osc.start();
                 osc.stop(this.ctx.currentTime + 0.3);
            }
            
            playWarp() {
                 if (this.ctx.state === 'suspended') this.ctx.resume();
                 const osc = this.ctx.createOscillator();
                 const gain = this.ctx.createGain();
                 osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                 osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 2.0);
                 osc.type = 'triangle';
                 gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                 gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2.0);
                 osc.connect(gain);
                 gain.connect(this.masterGain);
                 osc.start();
                 osc.stop(this.ctx.currentTime + 2.0);
            }

            playBossWarning() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 1.5);
                
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.5);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 1.5);
            }
        }

        // --- æ¸¸æˆä¸»é€»è¾‘ ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let soundMgr;
        
        let gameState = {
            width: 0, height: 0,
            score: 0, gameOver: true, frame: 0, shake: 0,
            
            // å…³å¡ç³»ç»Ÿ
            level: 1, enemiesKilledInLevel: 0, enemiesSpawnedInLevel: 0,
            levelTarget: 10, state: 'playing', transitionTimer: 0, warpSpeed: 1.0,
            
            // Boss ç³»ç»Ÿ
            isBossActive: false,
            
            // èƒŒæ™¯ç³»ç»Ÿ
            bgScrollY: 0,
            planetY: -200 // å·¨å¤§è¡Œæ˜Ÿä½ç½®
        };

        const player = { 
            x: 0, y: 0, w: 60, h: 60, hp: 100, maxHp: 100, 
            shield: false, weaponLevel: 1, 
            weaponType: 'normal' // 'normal' or 'laser'
        };
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        
        // èƒŒæ™¯å…ƒç´ 
        let starLayers = [];
        let nebulae = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameState.width = canvas.width;
            gameState.height = canvas.height;
            initBackgroundElements();
        }
        window.addEventListener('resize', resize);
        
        // --- é«˜çº§èƒŒæ™¯ç”Ÿæˆç³»ç»Ÿ ---
        function initBackgroundElements() {
            starLayers = [];
            // è¿œæ™¯æ˜Ÿæ˜Ÿ (å¤šä¸”æ…¢)
            const farStars = [];
            for(let i=0; i<200; i++) farStars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*1+0.5, speed: 0.2, alpha: Math.random()*0.5+0.1});
            starLayers.push(farStars);
            
            // ä¸­æ™¯æ˜Ÿæ˜Ÿ
            const midStars = [];
            for(let i=0; i<80; i++) midStars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*1.5+1, speed: 0.5, alpha: Math.random()*0.8+0.2});
            starLayers.push(midStars);
            
            // è¿‘æ™¯æ˜Ÿæ˜Ÿ (å°‘ä¸”å¿«ï¼Œäº®)
            const nearStars = [];
            for(let i=0; i<30; i++) nearStars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*2+1.5, speed: 1.2, alpha: 1.0});
            starLayers.push(nearStars);

            // ç¨‹åºåŒ–ç”Ÿæˆæ˜Ÿäº‘ (äº‘å›¢)
            nebulae = [];
            for(let i=0; i<15; i++) {
                nebulae.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 200 + 100,
                    colorStart: `hsla(${Math.random()*60 + 220}, 80%, 60%, 0)`, // Blue/Purple hue
                    colorEnd: `hsla(${Math.random()*60 + 240}, 60%, 20%, 0.15)`,
                    speed: 0.1
                });
            }
        }

        // --- è¾“å…¥æ§åˆ¶ ---
        let input = { x: canvas.width / 2, y: canvas.height - 100, active: false };
        
        const handleStart = (x, y) => { input.active = true; input.x = x; input.y = y; };
        const handleMove = (x, y) => { if(input.active) { input.x = x; input.y = y; } };
        const handleEnd = () => { input.active = false; };

        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', handleEnd);
        
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchend', handleEnd);

        // --- ç»˜å›¾å‡½æ•°ï¼šé€¼çœŸçš„èƒŒæ™¯ ---

        function drawRealisticBackground() {
            // 1. æ·±ç©ºåº•è‰² (Deep Space Void)
            const bgGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.height);
            bgGrad.addColorStop(0, '#0f172a'); // ææ·±çš„è“
            bgGrad.addColorStop(1, '#020617'); // é»‘è‰²è¾¹ç¼˜
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. è¿œæ™¯æ˜Ÿæ˜Ÿ
            drawStars(starLayers[0]);
            
            // 3. æ˜Ÿäº‘å±‚ (Nebulae) - ä½¿ç”¨ Screen æ··åˆæ¨¡å¼åˆ›é€ å‘å…‰æ„Ÿ
            ctx.globalCompositeOperation = 'screen';
            nebulae.forEach(neb => {
                neb.y += neb.speed * gameState.warpSpeed;
                if(neb.y - neb.radius > canvas.height) { neb.y = -neb.radius; neb.x = Math.random() * canvas.width; }
                
                const grad = ctx.createRadialGradient(neb.x, neb.y, 0, neb.x, neb.y, neb.radius);
                grad.addColorStop(0, neb.colorEnd); // ä¸­å¿ƒç¨å¾®é€ä¸€ç‚¹
                grad.addColorStop(0.4, neb.colorEnd);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(neb.x, neb.y, neb.radius, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalCompositeOperation = 'source-over';

            // 4. å·¨å‹è¡Œæ˜Ÿ (Planet) - ç¼“æ…¢ç§»åŠ¨
            gameState.planetY += 0.05 * gameState.warpSpeed;
            if(gameState.planetY > canvas.height + 400) gameState.planetY = -400;
            
            // è¡Œæ˜Ÿä½ç½® (èƒŒæ™¯æ·±å¤„)
            const px = canvas.width * 0.8;
            const py = gameState.planetY;
            const pr = 180;

            ctx.save();
            // è¡Œæ˜Ÿæœ¬ä½“
            const pGrad = ctx.createRadialGradient(px - 60, py - 60, 20, px, py, pr);
            pGrad.addColorStop(0, '#38bdf8'); // äº®é¢
            pGrad.addColorStop(0.5, '#0369a1');
            pGrad.addColorStop(1, '#0c4a6e'); // æš—é¢
            ctx.fillStyle = pGrad;
            ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI*2); ctx.fill();

            // è¡Œæ˜Ÿé˜´å½± (Terminator)
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.beginPath(); 
            ctx.arc(px, py, pr, 0, Math.PI*2); 
            ctx.clip();
            ctx.beginPath();
            ctx.arc(px + 80, py + 80, pr * 1.2, 0, Math.PI*2); // é”™ä½çš„åœ†æ¨¡æ‹Ÿæ–°æœˆé˜´å½±
            ctx.rect(0,0, canvas.width, canvas.height); // åå‘å¡«å……æ¯”è¾ƒéº»çƒ¦ï¼Œç®€å•ç”»ä¸ªé®ç½©
            ctx.fill();
            
            // è¡Œæ˜Ÿå¤§æ°”å±‚å…‰æ™•
            ctx.shadowColor = '#7dd3fc';
            ctx.shadowBlur = 50;
            ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI*2); ctx.stroke(); // ç©ºæè¾¹è§¦å‘ glow
            ctx.shadowBlur = 0;
            ctx.restore();

            // 5. ä¸­æ™¯å’Œè¿‘æ™¯æ˜Ÿæ˜Ÿ
            drawStars(starLayers[1]);
            drawStars(starLayers[2]);

            // 6. æš—è§’ (Vignette) - å¢åŠ ç”µå½±æ„Ÿ
            const vignette = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.height * 0.4, canvas.width/2, canvas.height/2, canvas.height * 0.8);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawStars(layer) {
            ctx.fillStyle = '#fff';
            layer.forEach(s => {
                s.y += s.speed * gameState.warpSpeed;
                if(s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; }
                
                ctx.globalAlpha = s.alpha;
                if(gameState.state === 'transition') {
                    // è·ƒè¿æ‹‰ä¸
                    ctx.fillRect(s.x, s.y - s.speed * 4, s.size, s.speed * 8);
                } else {
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawPlayerSprite() {
            // å¹³æ»‘ç§»åŠ¨
            player.x += (input.x - player.x) * 0.15;
            player.y += (input.y - player.y) * 0.15;

            // è¾¹ç•Œé™åˆ¶
            player.x = Math.max(30, Math.min(canvas.width - 30, player.x));
            player.y = Math.max(30, Math.min(canvas.height - 30, player.y));

            ctx.save();
            ctx.translate(player.x, player.y);
            if (gameState.state === 'transition') ctx.scale(0.9, 1.2); 

            // å¼•æ“å°¾ç„°
            const flameLen = (30 + Math.random() * 10) * (gameState.state === 'transition' ? 2 : 1);
            let flameColorStart = 'rgba(50, 200, 255, 0.8)';
            if (player.weaponType === 'laser') flameColorStart = 'rgba(255, 50, 255, 0.8)'; // æ¿€å…‰æ¨¡å¼ä¸‹å°¾ç„°å˜è‰²

            const flameGrad = ctx.createLinearGradient(0, 25, 0, 25 + flameLen);
            flameGrad.addColorStop(0, flameColorStart);
            flameGrad.addColorStop(1, 'rgba(0, 0, 255, 0)');
            
            ctx.fillStyle = flameGrad;
            ctx.beginPath(); ctx.moveTo(-15, 25); ctx.lineTo(-10, 25 + flameLen); ctx.lineTo(-5, 25); ctx.fill();
            ctx.beginPath(); ctx.moveTo(5, 25); ctx.lineTo(10, 25 + flameLen); ctx.lineTo(15, 25); ctx.fill();

            // æœºèº«ä¸»ä½“ (é“¶è‰²ç§‘å¹»æˆ˜æœº)
            // æœºç¿¼
            ctx.fillStyle = player.weaponType === 'laser' ? '#e2e8f0' : '#cbd5e1'; 
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(40, 20); ctx.lineTo(40, 30); ctx.lineTo(10, 20); ctx.lineTo(10, 35); 
            ctx.lineTo(20, 40); ctx.lineTo(-20, 40); ctx.lineTo(-10, 35); ctx.lineTo(-10, 20);
            ctx.lineTo(-40, 30); ctx.lineTo(-40, 20);
            ctx.closePath();
            ctx.fill();
            
            // æœºèº«ä¸­è½´é«˜å…‰
            const bodyGrad = ctx.createLinearGradient(-10, 0, 10, 0);
            bodyGrad.addColorStop(0, '#94a3b8'); bodyGrad.addColorStop(0.5, '#f1f5f9'); bodyGrad.addColorStop(1, '#94a3b8');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath(); ctx.moveTo(0, -40); ctx.lineTo(12, 10); ctx.lineTo(8, 40); ctx.lineTo(-8, 40); ctx.lineTo(-12, 10); ctx.closePath(); ctx.fill();

            // é©¾é©¶èˆ±
            const cockpitGrad = ctx.createLinearGradient(0, -15, 0, 5);
            cockpitGrad.addColorStop(0, player.weaponType === 'laser' ? '#d946ef' : '#0ea5e9'); // æ¿€å…‰æ¨¡å¼ä¸‹é©¾é©¶èˆ±å˜ç´«
            cockpitGrad.addColorStop(1, '#0f172a');
            ctx.fillStyle = cockpitGrad;
            ctx.beginPath(); ctx.ellipse(0, -5, 4, 10, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath(); ctx.arc(-1, -8, 1.5, 0, Math.PI*2); ctx.fill();

            // è£…é¥°çº¿
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-12, 10); ctx.lineTo(-25, 25); ctx.moveTo(12, 10); ctx.lineTo(25, 25); ctx.stroke();

            // æŠ¤ç›¾æ•ˆæœ
            if (player.shield) {
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.abs(Math.sin(gameState.frame * 0.1)) * 0.5 + 0.2})`;
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.arc(0, 0, 55, 0, Math.PI * 2); ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function drawEnemySprite(e) {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(1, -1); 

            if (e.type === 'boss') {
                // === BOSS ç»˜åˆ¶ ===
                ctx.save();
                ctx.scale(2, 2); // è§†è§‰ä¸Šæ”¾å¤§2å€ä»¥åŒ¹é…æ–°çš„ç¢°æ’ä½“ç§¯

                // ä¸»ä½“é˜´å½±
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;

                // æ ¸å¿ƒ
                ctx.fillStyle = '#450a0a';
                ctx.beginPath();
                ctx.moveTo(0, -60);
                ctx.lineTo(60, 20);
                ctx.lineTo(40, 50);
                ctx.lineTo(0, 40);
                ctx.lineTo(-40, 50);
                ctx.lineTo(-60, 20);
                ctx.closePath();
                ctx.fill();

                // æœºæ¢°çº¹ç†
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -60); ctx.lineTo(0, 40);
                ctx.moveTo(-60, 20); ctx.lineTo(60, 20);
                ctx.stroke();

                // å‘å…‰å¼•æ“
                ctx.fillStyle = '#fca5a5';
                ctx.beginPath(); ctx.arc(-30, 0, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(30, 0, 8, 0, Math.PI*2); ctx.fill();
                
                // æ ¸å¿ƒçº¢å…‰è„‰å†²
                const pulse = Math.abs(Math.sin(gameState.frame * 0.05));
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                
                // è¡€æ¡ (æ˜¾ç¤ºåœ¨ Boss ä¸Šæ–¹)
                ctx.scale(1, -1);
                ctx.fillStyle = 'red';
                ctx.fillRect(-50, -80, 100, 8);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-50, -80, 100 * (e.hp / e.maxHp), 8);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(-50, -80, 100, 8);
                
                ctx.restore(); // æ¢å¤ Boss ä¸“å±çš„ scale

            } else if (e.type === 'elite') {
                ctx.fillStyle = '#3f3f46';
                ctx.beginPath(); ctx.moveTo(0, -40); ctx.lineTo(30, 0); ctx.lineTo(50, 20); ctx.lineTo(50, 35); ctx.lineTo(20, 20); ctx.lineTo(0, 30); ctx.lineTo(-20, 20); ctx.lineTo(-50, 35); ctx.lineTo(-50, 20); ctx.lineTo(-30, 0); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#52525b'; ctx.beginPath(); ctx.arc(15, 10, 8, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-20, 5, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#b91c1c'; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
            } else if (e.type === 'fast') {
                ctx.fillStyle = '#b45309';
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(15, 10); ctx.lineTo(25, -10); ctx.lineTo(15, 20); ctx.lineTo(0, 25); ctx.lineTo(-15, 20); ctx.lineTo(-25, -10); ctx.lineTo(-15, 10); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(0, 5, 3, 6, 0, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = '#374151';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(20, 15); ctx.lineTo(0, 10); ctx.lineTo(-20, 15); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#22c55e'; ctx.fillRect(-10, 5, 20, 2);
            }

            if (e.type !== 'boss') {
                ctx.shadowBlur = 10; ctx.shadowColor = '#ef4444';
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(-8, 25, 2, 0, Math.PI*2); ctx.arc(8, 25, 2, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // --- æ¸¸æˆé€»è¾‘ ---
        function getLevelConfig() {
            return {
                target: 10 + (gameState.level - 1) * 5,
                maxOnScreen: 7, 
                spawnRate: 0.02 + (gameState.level * 0.005),
                allowElite: gameState.level >= 3,
                allowFast: gameState.level >= 2
            };
        }

        function spawnBoss() {
            gameState.isBossActive = true;
            // å¤§å¹…å¢åŠ  BOSS è¡€é‡ï¼Œç¡®ä¿æ¿€å…‰ç‚®ä¹Ÿéœ€è¦æ‰“å¾ˆä¹…
            // åŸºç¡€ 4000 è¡€ï¼Œæ¯çº§å¢åŠ  500ã€‚æ¿€å…‰ç‚® 120 DPSï¼Œéœ€è¦çº¦ 30 ç§’ã€‚
            const hp = 4000 + (gameState.level * 500);
            const boss = { 
                x: canvas.width / 2, y: -100, 
                w: 240, h: 200, // å°ºå¯¸ç¿»å€ (åŸ 120, 100)
                hp: hp, maxHp: hp, 
                type: 'boss', 
                vx: 2, vy: 0.4, // é€Ÿåº¦ç¿»å€ (åŸ 1, 0.2)
                movePattern: 0 
            };
            enemies.push(boss);
            
            // æ’­æ”¾è­¦å‘Š
            soundMgr.playBossWarning();
            const warningEl = document.getElementById('boss-warning');
            warningEl.style.display = 'block';
            setTimeout(() => { warningEl.style.display = 'none'; }, 3000);

            // æ‰è½æ¿€å…‰æ­¦å™¨æ ¸å¿ƒ
            setTimeout(() => {
                spawnPowerUp(canvas.width / 2, -50, 'laser');
            }, 1000);
        }

        function spawnEnemy() {
            if (gameState.state !== 'playing') return;
            
            // ä¿®æ”¹ï¼šBoss æˆ˜æœŸé—´ä¹Ÿå…è®¸ç”Ÿæˆæ™®é€šæ•Œäººï¼Œå¢åŠ éš¾åº¦
            // é™åˆ¶ Boss æˆ˜æœŸé—´å°æ€ªæ•°é‡ï¼Œé¿å…è¿‡äºå¡é¡¿
            if (gameState.isBossActive && enemies.length > 4) return;

            const config = getLevelConfig();
            // ä¿®æ”¹ï¼šå¦‚æœ Boss æ´»ç€ï¼Œä¸å—å…³å¡ç›®æ ‡æ•°é‡é™åˆ¶ï¼ŒæŒç»­å‡ºå…µ
            if (!gameState.isBossActive && gameState.enemiesSpawnedInLevel >= config.target) return;
            if (enemies.length >= config.maxOnScreen) return;

            if (Math.random() < config.spawnRate) { 
                const typeRand = Math.random();
                let enemy = { x: Math.random() * (canvas.width - 60) + 30, y: -60, w: 40, h: 40, hp: 2 + (gameState.level * 0.5), type: 'normal', vx: (Math.random() - 0.5) * 1.5, vy: Math.random() * 2 + 2 };
                if (config.allowElite && typeRand > 0.90) { enemy.w = 80; enemy.h = 60; enemy.hp = 15 + gameState.level; enemy.type = 'elite'; enemy.vy = 1; } 
                else if (config.allowFast && typeRand > 0.70) { enemy.w = 40; enemy.h = 40; enemy.hp = 4 + gameState.level; enemy.type = 'fast'; enemy.vy = 5; }
                enemies.push(enemy);
                
                // Boss æˆ˜äº§ç”Ÿçš„æ•Œäººä¸è®¡å…¥è¿‡å…³ç›®æ ‡
                if (!gameState.isBossActive) {
                    gameState.enemiesSpawnedInLevel++;
                }
            }
        }

        function shoot() {
            if (gameState.state !== 'playing') return; 
            
            // æ¿€å…‰æ­¦å™¨é€»è¾‘
            if (player.weaponType === 'laser') {
                if (gameState.frame % 4 === 0) { // æé«˜å°„é€Ÿ
                    soundMgr.playLaserShoot();
                    bullets.push({ 
                        x: player.x, y: player.y - 40, 
                        vx: 0, vy: -25, // æå¿«é€Ÿåº¦
                        type: 'laser', dmg: 8, 
                        color: '#d946ef', w: 10, h: 40 
                    });
                }
                return;
            }

            // æ™®é€šæ­¦å™¨é€»è¾‘
            if (gameState.frame % 8 === 0) { 
                soundMgr.playShoot();
                const createBullet = (offsetX, angle = 0) => ({ x: player.x + offsetX, y: player.y - 30, vx: Math.sin(angle)*2, vy: -18, type: 'bullet', dmg: 2, color: '#fef08a' });
                bullets.push(createBullet(-15));
                bullets.push(createBullet(15));
                if (player.weaponLevel >= 2) { bullets.push(createBullet(-25, -0.1)); bullets.push(createBullet(25, 0.1)); }
                if (player.weaponLevel >= 3 && gameState.frame % 32 === 0) {
                     bullets.push({x: player.x - 40, y: player.y, vx: -3, vy: -4, type: 'missile', dmg: 10, color: '#f97316', target: null, trail: []});
                     bullets.push({x: player.x + 40, y: player.y, vx: 3, vy: -4, type: 'missile', dmg: 10, color: '#f97316', target: null, trail: []});
                }
            }
        }

        function updateBullets() {
            bullets.forEach((b, index) => {
                if (b.type === 'laser') {
                    // æ¿€å…‰ç»˜åˆ¶
                    b.y += b.vy;
                    ctx.save();
                    ctx.shadowColor = '#d946ef'; ctx.shadowBlur = 15;
                    ctx.fillStyle = '#fae8ff';
                    ctx.fillRect(b.x - 4, b.y, 8, 60); // æ ¸å¿ƒäº®è‰²
                    ctx.fillStyle = 'rgba(217, 70, 239, 0.5)';
                    ctx.fillRect(b.x - 8, b.y - 10, 16, 80); // å¤–å‘å…‰
                    ctx.restore();
                } else if (b.type === 'missile') {
                    if (!b.target || b.target.hp <= 0) {
                        let minDist = Infinity;
                        enemies.forEach(e => {
                            const d = Math.hypot(e.x - b.x, e.y - b.y);
                            if (d < minDist && e.y < b.y && e.y > 0) { minDist = d; b.target = e; }
                        });
                    }
                    if (b.target) {
                        const angle = Math.atan2(b.target.y - b.y, b.target.x - b.x);
                        b.vx += Math.cos(angle) * 0.8; b.vy += Math.sin(angle) * 0.8;
                        const speed = Math.hypot(b.vx, b.vy);
                        if(speed > 12) { b.vx = (b.vx/speed)*12; b.vy = (b.vy/speed)*12; }
                    }
                    b.trail.push({x: b.x, y: b.y, age: 10});
                    ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI/2);
                    ctx.fillStyle = '#cbd5e1'; ctx.fillRect(-3, -10, 6, 20); 
                    ctx.fillStyle = '#ef4444'; ctx.fillRect(-3, 0, 6, 5); ctx.restore();
                    b.trail.forEach((t, i) => {
                        t.age--; ctx.fillStyle = `rgba(200, 200, 200, ${t.age/10})`;
                        ctx.beginPath(); ctx.arc(t.x, t.y, 4 - (t.age/10)*2, 0, Math.PI*2); ctx.fill();
                        if(t.age <= 0) b.trail.splice(i, 1);
                    });
                    b.x += b.vx; b.y += b.vy;
                } else {
                    b.x += b.vx; b.y += b.vy;
                    ctx.shadowBlur = 10; ctx.shadowColor = b.color;
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(b.x, b.y, 3, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
                }
                if (b.y < -50 || b.y > canvas.height || b.x < -50 || b.x > canvas.width) bullets.splice(index, 1);
            });
        }

        function createExplosion(x, y, color) {
            soundMgr.playExplosion();
            gameState.shake = 15; 
            for (let i = 0; i < 15; i++) {
                particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 30 + Math.random() * 20, color: color, size: Math.random() * 8 + 4, decay: 0.92 });
            }
        }

        function updateParticles() {
            particles.forEach((p, index) => {
                p.x += p.vx; p.y += p.vy; p.vx *= p.decay; p.vy *= p.decay; p.life--; p.size *= 0.95;
                ctx.globalCompositeOperation = 'lighter'; 
                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                grad.addColorStop(0, '#fff'); grad.addColorStop(0.5, p.color); grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.globalAlpha = p.life / 50; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
                if (p.life <= 0) particles.splice(index, 1);
            });
        }

        function spawnPowerUp(x, y, forcedType = null) {
            let type, color, text;
            if (forcedType === 'laser') {
                type = 'laser'; color = '#d946ef'; text = 'âš¡';
            } else {
                const r = Math.random();
                type = 'score'; color = '#fbbf24'; text = 'â­'; 
                if (r > 0.92) { type = 'shield'; color = '#06b6d4'; text = 'ğŸ›¡ï¸'; } 
                else if (r > 0.85) { type = 'weapon'; color = '#f43f5e'; text = 'ğŸš€'; } 
                else if (r > 0.75) { type = 'heal'; color = '#22c55e'; text = 'â•'; } 
            }
            powerups.push({ x, y, type, color, text, vy: 1.5, angle: 0 });
        }

        function updatePowerUps() {
            powerups.forEach((p, index) => {
                p.y += p.vy; p.angle += 0.05;
                ctx.save(); ctx.translate(p.x, p.y); ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.strokeStyle = p.color; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.stroke();
                ctx.rotate(Math.sin(p.angle) * 0.5); ctx.font = "20px Arial"; ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowBlur = 0; ctx.fillText(p.text, 0, 0); ctx.restore();
                const dist = Math.hypot(player.x - p.x, player.y - p.y);
                if (dist < 45) {
                    soundMgr.playPowerUp();
                    if (p.type === 'score') gameState.score += 500;
                    if (p.type === 'heal') player.hp = Math.min(player.hp + 30, player.maxHp);
                    if (p.type === 'weapon') { player.weaponLevel = Math.min(player.weaponLevel + 1, 3); document.querySelector('#weapon-icon span.text-blue-300').textContent = "LV." + player.weaponLevel; }
                    if (p.type === 'shield') {
                        player.shield = true;
                        document.getElementById('shield-icon').classList.remove('opacity-30', 'grayscale'); document.getElementById('shield-cd').classList.remove('hidden');
                        setTimeout(() => { player.shield = false; document.getElementById('shield-icon').classList.add('opacity-30', 'grayscale'); document.getElementById('shield-cd').classList.add('hidden'); }, 6000); 
                    }
                    if (p.type === 'laser') {
                        player.weaponType = 'laser';
                        // æç¤ºç”¨æˆ·
                        const hint = document.getElementById('start-hint');
                        hint.innerText = "è·å¾—æ¿€å…‰ç‚®ï¼å¨åŠ›å¤§å¢ï¼";
                        hint.style.color = "#d946ef";
                        setTimeout(() => { hint.innerText = "æ»‘åŠ¨å±å¹•æ§åˆ¶æˆ˜æœº / è‡ªåŠ¨å°„å‡»"; hint.style.color = "white"; }, 3000);
                    }
                    powerups.splice(index, 1);
                }
                if (p.y > canvas.height) powerups.splice(index, 1);
            });
        }

        function checkLevelStatus() {
            if (gameState.state !== 'playing') return;
            const config = getLevelConfig();
            
            // å¦‚æœæ˜¯ Boss æˆ˜é˜¶æ®µï¼Œä¸æ£€æŸ¥å¸¸è§„é€šå…³é€»è¾‘
            if (gameState.isBossActive) return;

            // æ¯ 10 å…³è§¦å‘ Boss
            if (gameState.enemiesSpawnedInLevel >= config.target && enemies.length === 0) {
                if (gameState.level % 10 === 0) {
                    spawnBoss();
                } else {
                    startLevelTransition();
                }
            }
        }

        function startLevelTransition() {
            gameState.state = 'transition'; gameState.transitionTimer = 180; gameState.warpSpeed = 1.0;
            soundMgr.playWarp();
        }

        function updateTransition() {
            if (gameState.state !== 'transition') return;
            gameState.transitionTimer--;
            if (gameState.transitionTimer > 90) gameState.warpSpeed += 0.5; else gameState.warpSpeed = Math.max(1.0, gameState.warpSpeed - 0.5);
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = "italic 900 40px 'Orbitron'"; ctx.fillStyle = '#00ffff'; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
            const scale = 1 + Math.sin(gameState.frame * 0.1) * 0.1; ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(scale, scale);
            ctx.fillText("WARP DRIVE ACTIVE", 0, -30);
            ctx.font = "30px 'ZCOOL KuaiLe'"; ctx.fillStyle = '#ffffff'; ctx.shadowBlur = 10; ctx.fillText(`æ­£åœ¨å‰å¾€ç¬¬ ${gameState.level + 1} å…³...`, 0, 30);
            ctx.restore();
            if (gameState.transitionTimer <= 0) {
                gameState.level++; gameState.enemiesKilledInLevel = 0; gameState.enemiesSpawnedInLevel = 0; gameState.state = 'playing'; gameState.warpSpeed = 1.0;
                document.getElementById('levelDisplay').innerText = `STAGE ${gameState.level}`;
                document.getElementById('killCount').innerText = 0; document.getElementById('levelTarget').innerText = getLevelConfig().target;
                player.hp = Math.min(player.maxHp, player.hp + 20);
            }
        }

        function checkCollisions() {
            bullets.forEach((b, bIdx) => {
                enemies.forEach((e, eIdx) => {
                    if (Math.abs(b.x - e.x) < e.w/2 && Math.abs(b.y - e.y) < e.h/2) {
                        e.hp -= b.dmg;
                        particles.push({ x: b.x, y: b.y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 5, color: '#fff', size: 2, decay: 0.8 });
                        // æ¿€å…‰å…·æœ‰ç©¿é€æ€§ï¼Œä¸é”€æ¯å­å¼¹ï¼›æ™®é€šå­å¼¹é”€æ¯
                        if (b.type !== 'laser') bullets.splice(bIdx, 1);
                        
                        if (e.hp <= 0) {
                            createExplosion(e.x, e.y, e.type === 'elite' || e.type === 'boss' ? '#fbbf24' : '#ef4444');
                            enemies.splice(eIdx, 1);
                            
                            // è®¡åˆ†
                            let scoreAdd = 200;
                            if (e.type === 'elite') scoreAdd = 1000;
                            if (e.type === 'boss') scoreAdd = 5000;
                            gameState.score += scoreAdd; 
                            
                            if (e.type !== 'boss') {
                                gameState.enemiesKilledInLevel++;
                                document.getElementById('killCount').innerText = gameState.enemiesKilledInLevel;
                            }
                            
                            if (e.type === 'boss') {
                                gameState.isBossActive = false;
                                player.weaponType = 'normal'; // Boss æ­»åæ¿€å…‰æ¶ˆå¤±
                                createExplosion(e.x, e.y, '#ff0000'); // é¢å¤–å¤§çˆ†ç‚¸
                                setTimeout(() => { createExplosion(e.x + 20, e.y - 20, '#ffaa00'); }, 100);
                                setTimeout(() => { createExplosion(e.x - 20, e.y + 20, '#ffff00'); }, 200);
                                startLevelTransition(); // å‡»è´¥ Boss åè¿‡å…³
                            } else {
                                if (Math.random() > 0.6) spawnPowerUp(e.x, e.y);
                            }
                        }
                    }
                });
            });
            enemies.forEach((e, index) => {
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                if (dist < (e.w + player.w) / 3) {
                    createExplosion(e.x, e.y, '#ff0000');
                    // Boss æ’å‡»ç›´æ¥æ¸¸æˆç»“æŸï¼Œæ™®é€šæ€ªæ‰£è¡€
                    if (e.type === 'boss') {
                        player.hp = 0;
                    } else {
                        enemies.splice(index, 1); gameState.enemiesKilledInLevel++; document.getElementById('killCount').innerText = gameState.enemiesKilledInLevel;
                        if (!player.shield) { player.hp -= 25; gameState.shake = 25; }
                    }
                }
            });
            const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
            document.getElementById('hpBar').style.width = `${hpPercent}%`;
            if (player.hp <= 0) gameOver();
        }

        function gameLoop() {
            if (gameState.gameOver) return;
            gameState.frame++;
            if (gameState.shake > 0) {
                const dx = (Math.random() - 0.5) * gameState.shake; const dy = (Math.random() - 0.5) * gameState.shake;
                ctx.save(); ctx.translate(dx, dy); gameState.shake *= 0.9; if(gameState.shake < 0.5) gameState.shake = 0;
            }

            drawRealisticBackground();
            drawPlayerSprite();
            
            if (gameState.state === 'playing') { shoot(); spawnEnemy(); checkLevelStatus(); } else { updateTransition(); }
            
            enemies.forEach(e => {
                // Boss ç§»åŠ¨é€»è¾‘ï¼šå·¦å³å¾˜å¾Š + ç¼“æ…¢ä¸‹å‹åˆ°å±å¹•ä¸­é—´
                if (e.type === 'boss') {
                    if (e.y < canvas.height / 2) e.y += 0.4; // å‹è¿›é€Ÿåº¦åŠ å€
                    e.x += Math.sin(gameState.frame * 0.04) * 3; // å·¦å³æ™ƒåŠ¨æ›´å‰§çƒˆ
                } else {
                    e.y += e.vy * (gameState.state === 'transition' ? 3 : 1); 
                    if(e.x < 0 || e.x > canvas.width) e.vx *= -1;
                }
                drawEnemySprite(e);
            });
            enemies = enemies.filter(e => e.y < canvas.height + 100);

            updateBullets(); updateParticles(); updatePowerUps(); checkCollisions();

            document.getElementById('scoreDisplay').innerText = `SCORE: ${gameState.score}`;
            if (gameState.shake > 0 || gameState.shake === 0 && ctx.getTransform().e !== 0) ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            resize();
            soundMgr = new SoundManager();
            gameState.gameOver = false; gameState.score = 0; gameState.frame = 0; gameState.level = 1; 
            gameState.enemiesKilledInLevel = 0; gameState.enemiesSpawnedInLevel = 0; 
            gameState.state = 'playing'; gameState.warpSpeed = 1.0; gameState.isBossActive = false;
            
            player.hp = 100; player.x = canvas.width / 2; player.y = canvas.height - 100; 
            player.weaponLevel = 1; player.shield = false; player.weaponType = 'normal';
            
            bullets = []; enemies = []; particles = []; powerups = [];
            document.getElementById('game-overlay').classList.add('hidden'); document.getElementById('result-area').classList.add('hidden');
            document.getElementById('levelDisplay').innerText = "STAGE 1"; document.getElementById('killCount').innerText = 0; document.getElementById('levelTarget').innerText = getLevelConfig().target;
            input.x = player.x; input.y = player.y;
            gameLoop();
        }

        function gameOver() {
            gameState.gameOver = true;
            document.getElementById('game-overlay').classList.remove('hidden'); document.getElementById('result-area').classList.remove('hidden');
            document.getElementById('final-score').innerText = gameState.score; document.getElementById('final-level').innerText = `æ­¢æ­¥äº STAGE ${gameState.level}`;
            document.getElementById('start-btn').innerText = "é‡æ•´æ——é¼“ RESTART";
        }

        document.getElementById('start-btn').addEventListener('click', startGame);

    </script>
</body>
</html>
