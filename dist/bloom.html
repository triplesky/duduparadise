
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture Bloom - è‰ºæœ¯ç”»å¸ƒ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Orbitron:wght@500&display=swap" rel="stylesheet">
    
    <!-- P5.js & ML5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'ZCOOL KuaiLe', cursive;
        }
        
        /* Glassmorphism Panel */
        .glass-panel {
            background: rgba(25, 25, 40, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #00ffff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-4 md:p-6">
        
        <!-- Header & Back Button -->
        <div class="flex justify-between items-start pointer-events-auto">
            <a href="gesture_nav.html" class="glass-panel w-12 h-12 flex items-center justify-center text-2xl text-white hover:bg-white/10 no-underline transition-colors">
                ğŸ 
            </a>
            <div class="text-right">
                <h1 class="text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 font-bold" style="font-family: 'Orbitron', sans-serif;">
                    GESTURE BLOOM
                </h1>
                <p class="text-white/60 text-xs md:text-sm tracking-widest mt-1">AI äº’åŠ¨è‰ºæœ¯ç”»å¸ƒ</p>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="flex justify-end pointer-events-auto">
            <div class="glass-panel p-4 w-full max-w-xs space-y-4">
                
                <!-- Density Slider -->
                <div>
                    <div class="flex justify-between text-xs text-cyan-300 font-bold mb-1">
                        <span>ç²’å­å¯†åº¦</span>
                        <span id="densityVal">5</span>
                    </div>
                    <input type="range" id="densitySlider" min="1" max="10" value="5" oninput="updateDensity(this.value)">
                </div>

                <!-- Theme Selector -->
                <div>
                    <div class="text-xs text-purple-300 font-bold mb-2">è‰²å½©ä¸»é¢˜</div>
                    <div class="flex gap-2">
                        <button onclick="changeTheme('cosmic')" class="flex-1 py-1 rounded border border-cyan-500/50 text-cyan-300 text-xs hover:bg-cyan-500/20 transition-colors bg-cyan-900/30">Cosmic</button>
                        <button onclick="changeTheme('forest')" class="flex-1 py-1 rounded border border-green-500/50 text-green-300 text-xs hover:bg-green-500/20 transition-colors">Forest</button>
                        <button onclick="changeTheme('sunset')" class="flex-1 py-1 rounded border border-orange-500/50 text-orange-300 text-xs hover:bg-orange-500/20 transition-colors">Sunset</button>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-2 pt-2">
                    <button onclick="resetCanvas()" class="flex-1 py-2 rounded bg-white/10 hover:bg-white/20 text-white text-sm font-bold border border-white/20 transition-colors">
                        æ¸…ç©ºç”»å¸ƒ
                    </button>
                </div>

                <!-- Gesture Guide -->
                <div class="pt-2 border-t border-white/10 text-[10px] text-white/50 space-y-1">
                    <p>ğŸ‘‰ é£ŸæŒ‡ç»˜ç”»ï¼šæ‹–å‡ºç²’å­è½¨è¿¹</p>
                    <p>ğŸŒ¸ å¼ å¼€äº”æŒ‡ï¼šè§¦å‘å…‰ç¯ç»½æ”¾ (Bloom)</p>
                    <p>âœŒï¸ èƒœåˆ©æ‰‹åŠ¿ï¼šè§¦å‘æ˜Ÿç³»æ—‹è½¬ (Galaxy)</p>
                    <p>âœŠ æ¡ç´§æ‹³å¤´ï¼šè§¦å‘éœ‡è¡æ³¢ (Ripple)</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading" class="absolute inset-0 z-50 bg-black flex flex-col items-center justify-center transition-opacity duration-500 pointer-events-none">
        <div class="loader mb-4"></div>
        <p class="text-cyan-400 font-bold tracking-wider animate-pulse">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰å¼•æ“...</p>
        <p id="error-msg" class="text-red-500 text-xs mt-4 hidden">æ— æ³•è®¿é—®æ‘„åƒå¤´</p>
    </div>

    <!-- P5.js Logic -->
    <script>
        let handPose;
        let video;
        let hands = [];
        let particles = [];
        let ripples = [];
        let galaxies = [];
        let blooms = [];
        
        // Configuration
        let particleDensity = 5;
        let theme = {
            name: 'cosmic',
            primary: [0, 255, 255], // Cyan
            secondary: [138, 43, 226], // Purple
            accent: [255, 255, 255]
        };

        // State tracking for gestures
        let prevOpenness = 0;
        let gestureCooldown = 0;

        function preload() {
            // Load the handPose model (ml5 v1.x syntax)
            handPose = ml5.handPose();
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            // Initialize Video (hidden)
            try {
                video = createCapture(VIDEO, {
                    video: {
                        facingMode: "user"
                    }
                });
                video.size(640, 480);
                video.hide();
                
                // Start detecting hands from the webcam video
                handPose.detectStart(video, gotHands);
            } catch(e) {
                console.error("Camera init failed:", e);
                document.getElementById('error-msg').classList.remove('hidden');
                document.getElementById('error-msg').innerText = "é”™è¯¯: æ— æ³•å¯åŠ¨æ‘„åƒå¤´";
            }

            background(0);
        }

        function gotHands(results) {
            hands = results;
            // Hide loading screen on first detection
            const loader = document.getElementById('loading');
            if (loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }
        }

        function draw() {
            // Trail effect background
            background(0, 0, 0, 20);

            // 1. Handle Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].show();
                if (particles[i].finished()) {
                    particles.splice(i, 1);
                }
            }

            // 2. Handle Ripples (Fist Effect)
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].update();
                ripples[i].show();
                // Distort particles
                for (let p of particles) {
                    let d = dist(p.pos.x, p.pos.y, ripples[i].x, ripples[i].y);
                    if (abs(d - ripples[i].radius) < 20) {
                        let force = p5.Vector.sub(p.pos, createVector(ripples[i].x, ripples[i].y));
                        force.normalize();
                        force.mult(5);
                        p.pos.add(force);
                    }
                }
                if (ripples[i].finished()) ripples.splice(i, 1);
            }

            // 3. Handle Galaxies (Peace Sign Effect)
            for (let i = galaxies.length - 1; i >= 0; i--) {
                galaxies[i].update();
                galaxies[i].show();
                if (galaxies[i].finished()) galaxies.splice(i, 1);
            }

             // 4. Handle Blooms (Open Hand Effect)
             for (let i = blooms.length - 1; i >= 0; i--) {
                blooms[i].update();
                blooms[i].show();
                if (blooms[i].finished()) blooms.splice(i, 1);
            }

            // 5. Hand Tracking Logic
            if (hands.length > 0) {
                let hand = hands[0];
                // In ml5 v1, landmarks are directly accessible
                let landmarks = hand.keypoints; 
                // Fallback for older versions if structure differs, but v1 usually uses keypoints or landmarks
                if (!landmarks && hand.landmarks) landmarks = hand.landmarks;

                if (landmarks) {
                    // Scale coordinates to fit full screen
                    let scaleX = width / video.width;
                    let scaleY = height / video.height;

                    // Draw Skeleton (Glowing Cyan)
                    drawSkeleton(landmarks, scaleX, scaleY);

                    // --- Gesture Logic ---
                    // Index finger tip is usually index 8
                    let indexTip = landmarks[8];
                    // ml5 v1 keypoints are objects {x, y, name} or arrays [x, y, z]
                    let ix, iy;
                    if (indexTip.x !== undefined) {
                        ix = (video.width - indexTip.x) * scaleX; // Mirror X
                        iy = indexTip.y * scaleY;
                    } else {
                        ix = (video.width - indexTip[0]) * scaleX;
                        iy = indexTip[1] * scaleY;
                    }

                    // Emit Trail from Index Finger
                    for (let i = 0; i < particleDensity; i++) {
                        particles.push(new Particle(ix, iy, theme));
                    }

                    // Analyze Gesture
                    if (gestureCooldown > 0) gestureCooldown--;
                    else analyzeGesture(landmarks, scaleX, scaleY);
                }
            }
        }

        function getPoint(landmarks, index) {
            let p = landmarks[index];
            if (p.x !== undefined) return [p.x, p.y];
            return [p[0], p[1]];
        }

        function drawSkeleton(landmarks, sx, sy) {
            noFill();
            stroke(theme.primary[0], theme.primary[1], theme.primary[2], 100);
            strokeWeight(2);
            // Draw connections (Finger lines)
            let fingers = [[0,1,2,3,4], [0,5,6,7,8], [0,9,10,11,12], [0,13,14,15,16], [0,17,18,19,20]];
            for (let i = 0; i < fingers.length; i++) {
                beginShape();
                for (let j = 0; j < fingers[i].length; j++) {
                    let idx = fingers[i][j];
                    let pt = getPoint(landmarks, idx);
                    let x = (video.width - pt[0]) * sx;
                    let y = pt[1] * sy;
                    vertex(x, y);
                    // Draw Joint
                    push();
                    noStroke();
                    fill(theme.primary[0], theme.primary[1], theme.primary[2], 150);
                    ellipse(x, y, 6);
                    pop();
                }
                endShape();
            }
        }

        function analyzeGesture(landmarks, sx, sy) {
            let wrist = getPoint(landmarks, 0);
            let tips = [
                getPoint(landmarks, 4), 
                getPoint(landmarks, 8), 
                getPoint(landmarks, 12), 
                getPoint(landmarks, 16), 
                getPoint(landmarks, 20)
            ]; 

            // Calculate average distance from tips to wrist (Openness)
            let totalDist = 0;
            for (let tip of tips) {
                totalDist += dist(tip[0], tip[1], wrist[0], wrist[1]);
            }
            let avgDist = totalDist / 5;
            
            // 1. Fist Detection (Ripple)
            if (avgDist < 60) { // Threshold for fist
                let kp9 = getPoint(landmarks, 9);
                let x = (video.width - kp9[0]) * sx; 
                let y = kp9[1] * sy;
                ripples.push(new Ripple(x, y, theme));
                gestureCooldown = 30;
                return;
            }

            // 2. Peace Sign (Galaxy)
            let pt8 = getPoint(landmarks, 8); // Index
            let pt12 = getPoint(landmarks, 12); // Middle
            let pt16 = getPoint(landmarks, 16); // Ring
            let pt20 = getPoint(landmarks, 20); // Pinky

            let dIndex = dist(pt8[0], pt8[1], wrist[0], wrist[1]);
            let dMiddle = dist(pt12[0], pt12[1], wrist[0], wrist[1]);
            let dRing = dist(pt16[0], pt16[1], wrist[0], wrist[1]);
            let dPinky = dist(pt20[0], pt20[1], wrist[0], wrist[1]);
            
            if (dIndex > 100 && dMiddle > 100 && dRing < 90 && dPinky < 90) {
                 let x = (video.width - pt8[0]) * sx;
                 let y = pt8[1] * sy;
                 galaxies.push(new Galaxy(x, y, theme));
                 gestureCooldown = 10; // Faster repeat for galaxy
                 return;
            }

            // 3. Bloom (Rapid Opening)
            if (avgDist - prevOpenness > 20 && avgDist > 120) {
                 let kp9 = getPoint(landmarks, 9);
                 let x = (video.width - kp9[0]) * sx; 
                 let y = kp9[1] * sy;
                 blooms.push(new Bloom(x, y, theme));
                 gestureCooldown = 40;
            }
            prevOpenness = avgDist;
        }

        // --- Particle System ---
        class Particle {
            constructor(x, y, t) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D();
                this.vel.mult(random(0.5, 2));
                this.acc = createVector(0, 0);
                this.life = 255;
                this.color = color(t.primary[0], t.primary[1], t.primary[2]);
                if (random() > 0.5) this.color = color(t.secondary[0], t.secondary[1], t.secondary[2]);
                this.size = random(2, 6);
            }

            update() {
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.life -= 4;
                this.acc.mult(0);
            }

            show() {
                noStroke();
                fill(red(this.color), green(this.color), blue(this.color), this.life);
                ellipse(this.pos.x, this.pos.y, this.size);
            }

            finished() {
                return this.life < 0;
            }
        }

        // --- Effect Classes ---
        class Ripple {
            constructor(x, y, t) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.alpha = 200;
                this.color = t.accent;
            }
            update() {
                this.radius += 10;
                this.alpha -= 5;
            }
            show() {
                noFill();
                stroke(this.color[0], this.color[1], this.color[2], this.alpha);
                strokeWeight(4);
                ellipse(this.x, this.y, this.radius * 2);
            }
            finished() { return this.alpha < 0; }
        }

        class Galaxy {
             constructor(x, y, t) {
                this.x = x;
                this.y = y;
                this.particles = [];
                for(let i=0; i<30; i++) {
                    let p = new Particle(x, y, t);
                    p.vel = createVector(cos(i), sin(i)).mult(random(2,5));
                    // Add rotational spin
                    p.angle = random(TWO_PI);
                    p.radius = random(10, 50);
                    this.particles.push(p);
                }
                this.life = 100;
            }
            update() {
                this.life -= 2;
                for(let p of this.particles) {
                    p.angle += 0.1;
                    p.radius += 1;
                    p.pos.x = this.x + cos(p.angle) * p.radius;
                    p.pos.y = this.y + sin(p.angle) * p.radius;
                    p.life -= 2; // Sync life
                }
            }
            show() {
                for(let p of this.particles) p.show();
            }
            finished() { return this.life < 0; }
        }

        class Bloom {
            constructor(x, y, t) {
                this.x = x;
                this.y = y;
                this.particles = [];
                for(let i=0; i<100; i++) {
                    let p = new Particle(x, y, t);
                    p.vel = p5.Vector.random2D().mult(random(5, 15)); // Fast burst
                    p.size = random(5, 10);
                    this.particles.push(p);
                }
            }
            update() {
                for(let p of this.particles) p.update();
            }
            show() {
                for(let p of this.particles) p.show();
            }
            finished() { 
                return this.particles[0].finished(); // Simple check
            }
        }

        // --- UI Functions ---
        function updateDensity(val) {
            particleDensity = parseInt(val);
            document.getElementById('densityVal').innerText = val;
        }

        function resetCanvas() {
            background(0);
            particles = [];
            ripples = [];
            galaxies = [];
            blooms = [];
        }

        function changeTheme(name) {
            if (name === 'cosmic') {
                theme = { primary: [0, 255, 255], secondary: [138, 43, 226], accent: [255, 255, 255] };
            } else if (name === 'forest') {
                theme = { primary: [0, 255, 127], secondary: [255, 215, 0], accent: [255, 255, 200] };
            } else if (name === 'sunset') {
                theme = { primary: [255, 69, 0], secondary: [255, 140, 0], accent: [255, 255, 100] };
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
