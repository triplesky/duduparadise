<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é­”æ³•æ‰‹åŠ¿ - å˜Ÿå˜Ÿä¹å›­</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000000; font-family: 'ZCOOL KuaiLe', cursive; user-select: none; }
        
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        /* è§†é¢‘éšè—ï¼Œç”¨äºåˆ†æ */
        #videoElement { 
            position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ä»¥åŒ¹é…è§†è§‰ä¹ æƒ¯ */
        }

        /* 3D ç”»å¸ƒ */
        #threeCanvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; 
        }

        /* 2D éª¨æ¶ç”»å¸ƒ */
        #overlayCanvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; 
            pointer-events: none; 
            transform: scaleX(-1);
        }

        /* UI å±‚ */
        #ui-layer { 
            position: absolute; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .pointer-events-auto { pointer-events: auto; }
        
        /* ç»ç’ƒæ‹Ÿæ€é¢æ¿ */
        .glass-panel {
            background: rgba(20, 20, 40, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        /* æ¨¡å‹é€‰æ‹©æŒ‰é’® */
        .shape-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .shape-btn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); }
        .shape-btn:active { transform: scale(0.95); }
        .shape-btn.active {
            background: rgba(139, 92, 246, 0.5); /* Violet-500 */
            border-color: #c4b5fd;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.6);
        }

        /* é¢œè‰²é€‰æ‹©å™¨è‡ªå®šä¹‰ */
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 36px; height: 36px;
            border-radius: 50%; overflow: hidden; cursor: pointer; padding: 0;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        /* æ»‘åŠ¨æ¡è‡ªå®šä¹‰ */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #a855f7;
            border-radius: 50%;
            width: 50px; height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* æç¤ºè¯åŠ¨æ•ˆ */
        .glow-text {
            text-shadow: 0 0 10px rgba(167, 139, 250, 0.8), 0 0 20px rgba(167, 139, 250, 0.4);
        }
    </style>
</head>
<body>

    <div id="container">
        <video id="videoElement" playsinline autoplay></video>
        <canvas id="threeCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
        
        <!-- UI ç•Œé¢ -->
        <div id="ui-layer" class="p-4 md:p-6">
            
            <!-- é¡¶éƒ¨æ  -->
            <div class="flex justify-between items-center w-full pointer-events-auto">
                <a href="gesture_nav.html" class="glass-panel w-12 h-12 flex items-center justify-center text-2xl text-white hover:bg-white/10 transition-colors no-underline">
                    ğŸ 
                </a>
                
                <div class="text-center md:absolute md:left-1/2 md:-translate-x-1/2">
                    <h1 class="text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-300 via-purple-300 to-pink-300 font-bold glow-text">
                        Gemini é­”æ³•
                    </h1>
                </div>

                <button onclick="toggleFullScreen()" class="glass-panel w-12 h-12 flex items-center justify-center text-xl text-white hover:bg-white/10 transition-colors">
                    â›¶
                </button>
            </div>

            <!-- åŠ è½½é®ç½© -->
            <div id="loading" class="absolute inset-0 flex flex-col items-center justify-center bg-black/95 z-50 pointer-events-auto transition-opacity duration-500">
                <div class="loader mb-6"></div>
                <div class="text-2xl text-purple-300 font-bold mb-2">æ­£åœ¨å¯åŠ¨ç²’å­å¼•æ“...</div>
                <div class="text-sm text-gray-400">è¯·å…è®¸æ‘„åƒå¤´æƒé™ â€¢ ä½¿ç”¨ GPU åŠ é€Ÿ</div>
            </div>

            <!-- åº•éƒ¨æ§åˆ¶é¢æ¿ -->
            <div class="flex justify-center w-full pointer-events-auto mt-auto">
                <div class="glass-panel p-4 w-full max-w-4xl flex flex-col md:flex-row gap-6 items-center justify-between">
                    
                    <!-- å·¦ä¾§ï¼šçŠ¶æ€ä¸æ§åˆ¶ -->
                    <div class="flex items-center gap-6 w-full md:w-auto justify-center md:justify-start">
                        <!-- é¢œè‰²é€‰æ‹© -->
                        <div class="flex flex-col items-center gap-1 group cursor-pointer" title="ç²’å­é¢œè‰²">
                            <div class="relative w-10 h-10 rounded-full hover:scale-110 transition-transform">
                                <div class="absolute inset-0 rounded-full animate-pulse bg-white/20"></div>
                                <input type="color" id="colorPicker" value="#8b5cf6" class="relative z-10">
                            </div>
                        </div>

                        <!-- å›å¼¹ç³»æ•°æ»‘å— (ä¿®æ”¹æ ‡é¢˜ä»¥åŒ¹é…åŠŸèƒ½) -->
                        <div class="flex flex-col w-24 gap-1">
                            <div class="flex justify-between text-[10px] text-gray-300 font-bold uppercase">
                                <span>æ— å›å¼¹</span>
                                <span>Qå¼¹</span>
                            </div>
                            <!-- é»˜è®¤å€¼æ”¹ä¸º 0.5 -->
                            <input type="range" id="bounceSlider" min="0" max="1" step="0.01" value="0.5" title="è°ƒæ•´å›å¼¹å¹…åº¦">
                        </div>
                        
                        <div class="h-10 w-[1px] bg-white/20"></div>
                        
                        <!-- çŠ¶æ€æŒ‡ç¤º -->
                        <div class="text-left min-w-[80px]">
                            <div class="text-xs text-purple-200 opacity-70 mb-1 tracking-wider">STATUS</div>
                            <div id="gestureStatus" class="text-base font-bold text-white flex items-center gap-2">
                                <span class="w-2 h-2 rounded-full bg-red-500 animate-pulse" id="statusDot"></span>
                                ç­‰å¾…...
                            </div>
                        </div>
                    </div>

                    <!-- å³ä¾§ï¼šæ¨¡å‹é€‰æ‹©ç½‘æ ¼ -->
                    <div class="flex gap-3 overflow-x-auto w-full md:justify-end pb-2 md:pb-0 no-scrollbar items-center">
                        <button onclick="setShape('heart')" id="btn-heart" class="shape-btn active border border-white/10 rounded-2xl px-3 py-3 min-w-[70px] flex flex-col items-center gap-1">
                            <span class="text-2xl">â¤ï¸</span>
                            <span class="text-xs font-bold text-gray-200">çˆ±å¿ƒ</span>
                        </button>
                        <button onclick="setShape('galaxy')" id="btn-galaxy" class="shape-btn border border-white/10 rounded-2xl px-3 py-3 min-w-[70px] flex flex-col items-center gap-1">
                            <span class="text-2xl">ğŸŒ€</span>
                            <span class="text-xs font-bold text-gray-200">æ˜Ÿç³»</span>
                        </button>
                        <button onclick="setShape('saturn')" id="btn-saturn" class="shape-btn border border-white/10 rounded-2xl px-3 py-3 min-w-[70px] flex flex-col items-center gap-1">
                            <span class="text-2xl">ğŸª</span>
                            <span class="text-xs font-bold text-gray-200">åœŸæ˜Ÿ</span>
                        </button>
                        <button onclick="setShape('atom')" id="btn-atom" class="shape-btn border border-white/10 rounded-2xl px-3 py-3 min-w-[70px] flex flex-col items-center gap-1">
                            <span class="text-2xl">âš›ï¸</span>
                            <span class="text-xs font-bold text-gray-200">åŸå­</span>
                        </button>
                         <button onclick="setShape('infinity')" id="btn-infinity" class="shape-btn border border-white/10 rounded-2xl px-3 py-3 min-w-[70px] flex flex-col items-center gap-1">
                            <span class="text-2xl">â™¾ï¸</span>
                            <span class="text-xs font-bold text-gray-200">æ— é™</span>
                        </button>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- ES Module é€»è¾‘ -->
    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

        // === 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ ===
        const config = {
            particleCount: 12000, 
            particleSize: 0.25,   
            baseColor: new THREE.Color('#a78bfa'), 
        };

        const state = {
            currentShape: 'heart',
            handOpenness: 1.0, // 0 (æ¡æ‹³/æ‰“æ•£) - 1 (å¼ å¼€/èšåˆ)
            isGripping: false, // æ˜¯å¦æ¡æ‹³
            handPosition: new THREE.Vector3(0, 0, 0),
            handRotation: new THREE.Quaternion(),
            hasHand: false
        };

        // DOM
        const video = document.getElementById('videoElement');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        const gestureStatus = document.getElementById('gestureStatus');
        const statusDot = document.getElementById('statusDot');
        const colorPicker = document.getElementById('colorPicker');
        const bounceSlider = document.getElementById('bounceSlider');

        // === 2. MediaPipe åˆå§‹åŒ– ===
        let handLandmarker = null;
        let lastVideoTime = -1;

        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                startCamera();
            } catch (error) {
                console.error("MediaPipe Init Error:", error);
                loadingScreen.innerHTML = `<div class='text-red-400'>åˆå§‹åŒ–å¤±è´¥<br>${error.message}</div>`;
            }
        }

        async function startCamera() {
            try {
                const constraints = { video: { facingMode: "user", width: 640, height: 480 } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => loadingScreen.style.display = 'none', 500);
                    initThreeJS();
                    renderLoop();
                });
            } catch (error) {
                console.error("Camera Error:", error);
                alert("è¯·å…è®¸è®¿é—®æ‘„åƒå¤´ä»¥ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶åŠŸèƒ½ã€‚");
            }
        }

        // === 3. Three.js é«˜çº§ç²’å­ç³»ç»Ÿ ===
        let scene, camera, renderer, particles;
        let positions, velocities, targetPositions;
        let particleGeometry;
        
        function createCrystalTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
            ctx.fillRect(4, 4, 24, 24);
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function initThreeJS() {
            const canvas = document.getElementById('threeCanvas');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.015);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const count = config.particleCount;
            positions = new Float32Array(count * 3);
            velocities = new Float32Array(count * 3);
            targetPositions = new Float32Array(count * 3);

            for (let i = 0; i < count * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
                velocities[i] = 0;
            }

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: config.baseColor,
                size: config.particleSize,
                map: createCrystalTexture(),
                transparent: true,
                opacity: 0.9, 
                blending: THREE.NormalBlending, 
                depthWrite: false,
                sizeAttenuation: true
            });

            particles = new THREE.Points(particleGeometry, material);
            scene.add(particles);

            calculateTargetShape('heart');
            
            colorPicker.addEventListener('input', (e) => {
                const c = new THREE.Color(e.target.value);
                particles.material.color.set(c);
            });

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            overlayCanvas.width = window.innerWidth;
            overlayCanvas.height = window.innerHeight;
        }

        // === 4. å½¢çŠ¶æ•°å­¦ç”Ÿæˆ ===
        function calculateTargetShape(shapeType) {
            state.currentShape = shapeType;
            
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${shapeType}`).classList.add('active');

            const count = config.particleCount;
            const scale = 1.0; 

            let pts = [];

            if (shapeType === 'heart') {
                // ç©ºå¿ƒéœ“è™¹å¿ƒå½¢ (Hollow Outline/Tube)
                // ç¡®ä¿å¿ƒå½¢æ˜¯æŒ‰ç…§æˆªå›¾ä¸­çš„è½®å»“ç”Ÿæˆï¼Œè€Œä¸æ˜¯å®å¿ƒ
                for (let i = 0; i < count; i++) {
                    // ä¸»è½®å»“ t
                    const t = (i / count) * Math.PI * 2 * 15; // å¢åŠ å¾ªç¯å¯†åº¦
                    const t_mod = t % (Math.PI * 2);
                    
                    // å¿ƒå½¢æ–¹ç¨‹
                    let hx = 16 * Math.pow(Math.sin(t_mod), 3);
                    let hy = 13 * Math.cos(t_mod) - 5 * Math.cos(2*t_mod) - 2 * Math.cos(3*t_mod) - Math.cos(4*t_mod);
                    let hz = 0;

                    // åœ¨è½®å»“çº¿ä¸Šæ·»åŠ éšæœºæŠ–åŠ¨ï¼Œå½¢æˆç®¡çŠ¶åšåº¦
                    const thickness = 1.5; 
                    const randAngle = Math.random() * Math.PI * 2;
                    const r = Math.random() * thickness;
                    
                    hx += r * Math.cos(randAngle);
                    hy += r * Math.sin(randAngle);
                    hz += (Math.random() - 0.5) * thickness * 2;

                    const s = 0.8; 
                    pts.push(hx * s, (hy + 2) * s, hz * s); 
                }
            } else {
                for (let i = 0; i < count; i++) {
                    let x, y, z;
                    switch (shapeType) {
                        case 'galaxy': {
                            const arms = 3;
                            const armAngle = (Math.random() * Math.PI * 2 * arms); 
                            const distance = Math.pow(Math.random(), 2) * 15;
                            const angle = armAngle + distance * 0.5;
                            x = Math.cos(angle) * distance;
                            y = (Math.random() - 0.5) * (15 / (distance + 1));
                            z = Math.sin(angle) * distance;
                            break;
                        }
                        case 'saturn': {
                            const ratio = 0.4;
                            if (i < count * ratio) {
                                const u = Math.random() * Math.PI * 2;
                                const v = Math.acos(2 * Math.random() - 1);
                                const r = 6;
                                x = r * Math.sin(v) * Math.cos(u);
                                y = r * Math.sin(v) * Math.sin(u);
                                z = r * Math.cos(v);
                            } else {
                                const angle = Math.random() * Math.PI * 2;
                                const r = 9 + Math.random() * 8; 
                                x = r * Math.cos(angle);
                                z = r * Math.sin(angle);
                                y = (Math.random() - 0.5) * 0.3;
                            }
                            const tilt = 0.4;
                            const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                            const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                            y = ty; z = tz;
                            break;
                        }
                        case 'atom': {
                            const ratio = 0.2;
                            if (i < count * ratio) {
                                const u = Math.random() * Math.PI * 2;
                                const v = Math.acos(2 * Math.random() - 1);
                                const r = 3;
                                x = r * Math.sin(v) * Math.cos(u);
                                y = r * Math.sin(v) * Math.sin(u);
                                z = r * Math.cos(v);
                            } else {
                                const orbit = Math.floor(Math.random() * 3);
                                const angle = Math.random() * Math.PI * 2;
                                const r = 12;
                                let bx = r * Math.cos(angle);
                                let by = r * Math.sin(angle);
                                let bz = (Math.random()-0.5) * 1;
                                if (orbit === 0) { x = bx; y = by; z = bz; }
                                else if (orbit === 1) { 
                                    x = bx * 0.5 - bz * 0.866;
                                    z = bx * 0.866 + bz * 0.5;
                                    y = by;
                                } else {
                                    x = bx;
                                    y = by * 0.5 - bz * 0.866;
                                    z = by * 0.866 + bz * 0.5;
                                }
                            }
                            break;
                        }
                        case 'infinity': {
                            const t = Math.random() * Math.PI * 2;
                            const tube = (Math.random() - 0.5) * 1.5;
                            const s = 12;
                            x = (s * Math.cos(t)) / (1 + Math.sin(t)*Math.sin(t));
                            y = (s * Math.cos(t) * Math.sin(t)) / (1 + Math.sin(t)*Math.sin(t));
                            z = tube;
                            x += (Math.random()-0.5); y += (Math.random()-0.5);
                            break;
                        }
                    }
                    pts.push(x, y, z);
                }
            }

            for (let i = 0; i < count; i++) {
                targetPositions[i*3]   = pts[i*3] * scale;
                targetPositions[i*3+1] = pts[i*3+1] * scale;
                targetPositions[i*3+2] = pts[i*3+2] * scale;
            }
        }

        window.setShape = calculateTargetShape;
        window.toggleFullScreen = () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        // === 5. æ¸²æŸ“å¾ªç¯ (ç‰©ç†å¼•æ“) ===
        function renderLoop() {
            requestAnimationFrame(renderLoop);
            processHandGesture();
            updateParticlePhysics();
            renderer.render(scene, camera);
        }

        function processHandGesture() {
            if (video.currentTime !== lastVideoTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                
                overlayCanvas.width = video.videoWidth; overlayCanvas.height = video.videoHeight;
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                if (result.landmarks.length > 0) {
                    state.hasHand = true;
                    const landmarks = result.landmarks[0];
                    drawSkeleton(overlayCtx, landmarks);
                    updateHandPosition3D(landmarks);

                    // === æ‰‹åŠ¿è¯†åˆ« ===
                    const wrist = landmarks[0];
                    const middleBase = landmarks[9];
                    const palmSize = Math.hypot(middleBase.x - wrist.x, middleBase.y - wrist.y);
                    
                    const tips = [4, 8, 12, 16, 20]; 
                    let tipsDist = 0;
                    tips.forEach(i => {
                        tipsDist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y);
                    });
                    const avgTipDist = tipsDist / 5;

                    const rawRatio = avgTipDist / (palmSize || 0.1);

                    // --- CALIBRATION ---
                    const minRatio = 0.8;
                    const maxRatio = 1.7;

                    let normalized = (rawRatio - minRatio) / (maxRatio - minRatio);
                    normalized = Math.max(0, Math.min(1, normalized)); 

                    if (normalized > 0.8) normalized = 1.0; 
                    else if (normalized < 0.2) normalized = 0.0; 

                    state.handOpenness = normalized;
                    state.isGripping = state.handOpenness < 0.2;

                    const percent = Math.round(state.handOpenness * 100);
                    statusDot.className = state.isGripping ? "w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_red]" : "w-3 h-3 rounded-full bg-green-400 shadow-[0_0_10px_lime]";
                    gestureStatus.innerHTML = state.isGripping 
                        ? `<span class="text-red-300">æ‰“æ•£ (${percent}%)</span>` 
                        : `<span class="text-green-300">èšåˆ (${percent}%)</span>`;

                } else {
                    state.hasHand = false;
                    state.handOpenness = 1.0; // é»˜è®¤å¼ å¼€
                    state.isGripping = false;
                    state.handPosition.lerp(new THREE.Vector3(0,0,0), 0.05);
                    statusDot.className = "w-2 h-2 rounded-full bg-gray-500";
                    gestureStatus.textContent = "æœªæ£€æµ‹åˆ°æ‰‹";
                }
            }
        }

        function updateHandPosition3D(landmarks) {
            const wrist = landmarks[0];
            const middle = landmarks[9];
            const cx = (wrist.x + middle.x) / 2;
            const cy = (wrist.y + middle.y) / 2;
            const ndcX = (1 - cx) * 2 - 1; 
            const ndcY = -(cy * 2 - 1);
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; 
            const targetPos = camera.position.clone().add(dir.multiplyScalar(distance));
            state.handPosition.lerp(targetPos, 0.15);

            if (state.hasHand) {
                const dx = middle.x - wrist.x;
                const dy = middle.y - wrist.y;
                const angle = Math.atan2(dy, dx);
                particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, -angle - Math.PI/2, 0.1);
            }
        }

        function updateParticlePhysics() {
            if (!particles) return;
            const posAttr = particles.geometry.attributes.position;
            const count = config.particleCount;
            
            // === 1. è·å–æ»‘å—å€¼å¹¶æ˜ å°„ç‰©ç†å‚æ•° ===
            const bounceInput = parseFloat(bounceSlider.value);
            
            // é˜»å°¼ (Friction): 
            // Input 0 (æ— å›å¼¹) -> friction 0.6 (High damping, stops fast)
            // Input 1 (Qå¼¹)   -> friction 0.96 (Low damping, oscillates)
            const friction = 0.6 + (bounceInput * 0.36); 

            // === 2. æ¡æ‹³/å¼ å¼€ é€»è¾‘ç¿»è½¬ ===
            // gripStrength: 0(Open) -> 1(Closed)
            const gripStrength = 1.0 - state.handOpenness; 

            // å¼¹åŠ› (Spring): 
            // Open(1.0) -> springStrength é«˜ -> èšæ‹¢
            // Closed(0.0) -> springStrength ä½ -> ä¸èšæ‹¢ï¼Œæ–¹ä¾¿æ‰“æ•£
            const baseSpring = 0.05;
            const springStrength = baseSpring * state.handOpenness; 

            // æ··æ²ŒåŠ› (Chaos): 
            // Open(1.0) -> chaos 0 -> ç¨³å®š
            // Closed(0.0) -> chaos é«˜ -> æ‰“æ•£
            const chaosLevel = gripStrength * 3.0; // å¼ºåŠ›æ‰“æ•£

            // ç›®æ ‡ç¼©æ”¾ (Target Scale): 
            // æ¡æ‹³æ—¶ï¼Œæ¨¡å‹è†¨èƒ€ (Expansion)ï¼Œè§†è§‰ä¸Šæ›´åƒâ€œç‚¸å¼€â€
            const targetScale = 1.0 + (gripStrength * 1.5); 

            const shapeCenterOffset = state.handPosition.clone().multiplyScalar(0.8);

            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                
                const px = posAttr.array[idx];
                const py = posAttr.array[idx+1];
                const pz = posAttr.array[idx+2];
                
                let tx = (targetPositions[idx] * targetScale) + shapeCenterOffset.x;
                let ty = (targetPositions[idx+1] * targetScale) + shapeCenterOffset.y;
                let tz = (targetPositions[idx+2] * targetScale) + shapeCenterOffset.z;

                // 1. æ··æ²Œ/æ‰“æ•£åŠ› (Chaos Force)
                // å½“æ¡æ‹³æ—¶æ–½åŠ éšæœºæ–¹å‘çš„åŠ›ï¼Œæ¨¡æ‹Ÿç‚¸è£‚
                if (chaosLevel > 0.1) {
                    // ä½¿ç”¨ç¡®å®šæ€§éšæœºæ•°ä»¥ä¿æŒå™ªç‚¹çº¹ç†ï¼Œæˆ–è€…å®Œå…¨éšæœº
                    // è¿™é‡Œä½¿ç”¨å®Œå…¨éšæœºä»¥è·å¾—çˆ†å‘æ„Ÿ
                    velocities[idx]   += (Math.random() - 0.5) * chaosLevel;
                    velocities[idx+1] += (Math.random() - 0.5) * chaosLevel;
                    velocities[idx+2] += (Math.random() - 0.5) * chaosLevel;
                }

                // 2. å¼¹åŠ›å½’ä½ (Spring Force)
                // åªæœ‰å½“æ‰‹å¼ å¼€æ—¶ï¼Œå¼¹åŠ›æ‰èµ·ä½œç”¨å°†ç²’å­æ‹‰å›å½¢çŠ¶
                if (springStrength > 0.001) {
                    velocities[idx]   += (tx - px) * springStrength;
                    velocities[idx+1] += (ty - py) * springStrength;
                    velocities[idx+2] += (tz - pz) * springStrength;
                }

                // 3. é˜»å°¼ (Friction)
                velocities[idx]   *= friction;
                velocities[idx+1] *= friction;
                velocities[idx+2] *= friction;

                posAttr.array[idx]   += velocities[idx];
                posAttr.array[idx+1] += velocities[idx+1];
                posAttr.array[idx+2] += velocities[idx+2];
            }

            posAttr.needsUpdate = true;
            
            if (state.currentShape !== 'galaxy') {
                particles.rotation.y += 0.002;
            }
        }

        function drawSkeleton(ctx, landmarks) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            const fingers = [[0,1,2,3,4],[0,5,6,7,8],[5,9,10,11,12],[9,13,14,15,16],[13,17,18,19,20]];
            
            const color = state.isGripping ? 'rgba(255, 50, 50, 0.8)' : 'rgba(0, 255, 200, 0.8)';
            ctx.strokeStyle = color;

            fingers.forEach(chain => {
                ctx.beginPath();
                ctx.moveTo(landmarks[chain[0]].x * w, landmarks[chain[0]].y * h);
                for(let i=1; i<chain.length; i++) ctx.lineTo(landmarks[chain[i]].x * w, landmarks[chain[i]].y * h);
                ctx.stroke();
            });

            ctx.fillStyle = '#fff';
            landmarks.forEach(lm => { 
                ctx.beginPath(); ctx.arc(lm.x * w, lm.y * h, 3, 0, Math.PI*2); ctx.fill(); 
            });
        }

        initMediaPipe();

    </script>
</body>
</html>